{"ast":null,"code":"// src/index.tsx\nimport * as React from \"react\";\nimport { useContext, useState, useRef, useEffect } from \"react\";\nimport { useMemoOne, useOnce, raf } from \"@react-spring/shared\";\nimport { a, Controller, config as configs } from \"@react-spring/web\";\nvar ParentContext = React.createContext(null);\nfunction getScrollType(horizontal) {\n  return horizontal ? \"scrollLeft\" : \"scrollTop\";\n}\nfunction mapChildrenRecursive(children, callback) {\n  const isReactFragment = node => {\n    if (node.type) {\n      return node.type === React.Fragment;\n    }\n    return node === React.Fragment;\n  };\n  return React.Children.map(children, child => isReactFragment(child) ? mapChildrenRecursive(child.props.children, callback) : callback(child));\n}\nvar START_TRANSLATE_3D = \"translate3d(0px,0px,0px)\";\nvar START_TRANSLATE = \"translate(0px,0px)\";\nvar ParallaxLayer = React.memo(React.forwardRef(({\n  horizontal,\n  factor = 1,\n  offset = 0,\n  speed = 0,\n  sticky,\n  ...rest\n}, ref) => {\n  const parent = useContext(ParentContext);\n  const ctrl = useMemoOne(() => {\n    let translate;\n    if (sticky) {\n      const start = sticky.start || 0;\n      translate = start * parent.space;\n    } else {\n      const targetScroll = Math.floor(offset) * parent.space;\n      const distance = parent.space * offset + targetScroll * speed;\n      translate = -(parent.current * speed) + distance;\n    }\n    return new Controller({\n      space: sticky ? parent.space : parent.space * factor,\n      translate\n    });\n  }, []);\n  const layer = useMemoOne(() => ({\n    horizontal: horizontal === void 0 || sticky ? parent.horizontal : horizontal,\n    sticky: void 0,\n    isSticky: false,\n    setPosition(height, scrollTop, immediate = false) {\n      if (sticky) {\n        setSticky(height, scrollTop);\n      } else {\n        const targetScroll = Math.floor(offset) * height;\n        const distance = height * offset + targetScroll * speed;\n        ctrl.start({\n          translate: -(scrollTop * speed) + distance,\n          config: parent.config,\n          immediate\n        });\n      }\n    },\n    setHeight(height, immediate = false) {\n      ctrl.start({\n        space: sticky ? height : height * factor,\n        config: parent.config,\n        immediate\n      });\n    }\n  }), []);\n  useOnce(() => {\n    if (sticky) {\n      const start = sticky.start || 0;\n      const end = sticky.end || start + 1;\n      layer.sticky = {\n        start,\n        end\n      };\n    }\n  });\n  React.useImperativeHandle(ref, () => layer);\n  const layerRef = useRef();\n  const setSticky = (height, scrollTop) => {\n    const start = layer.sticky.start * height;\n    const end = layer.sticky.end * height;\n    const isSticky = scrollTop >= start && scrollTop <= end;\n    if (isSticky === layer.isSticky) return;\n    layer.isSticky = isSticky;\n    const ref2 = layerRef.current;\n    ref2.style.position = isSticky ? \"sticky\" : \"absolute\";\n    ctrl.set({\n      translate: isSticky ? 0 : scrollTop < start ? start : end\n    });\n  };\n  useOnce(() => {\n    if (parent) {\n      parent.layers.add(layer);\n      parent.update();\n      return () => {\n        parent.layers.delete(layer);\n        parent.update();\n      };\n    }\n  });\n  const translate3d = ctrl.springs.translate.to(layer.horizontal ? x => `translate3d(${x}px,0,0)` : y => `translate3d(0,${y}px,0)`);\n  return /* @__PURE__ */React.createElement(a.div, {\n    ...rest,\n    ref: layerRef,\n    style: {\n      position: \"absolute\",\n      top: 0,\n      bottom: 0,\n      left: 0,\n      right: 0,\n      backgroundSize: \"auto\",\n      backgroundRepeat: \"no-repeat\",\n      willChange: \"transform\",\n      [layer.horizontal ? \"height\" : \"width\"]: \"100%\",\n      [layer.horizontal ? \"width\" : \"height\"]: ctrl.springs.space,\n      WebkitTransform: translate3d,\n      msTransform: translate3d,\n      transform: translate3d,\n      ...rest.style\n    }\n  });\n}));\nvar Parallax = React.memo(React.forwardRef((props, ref) => {\n  const [ready, setReady] = useState(false);\n  const {\n    pages,\n    innerStyle: _innerStyle,\n    config = configs.slow,\n    enabled = true,\n    horizontal = false,\n    children,\n    ...rest\n  } = props;\n  const containerRef = useRef();\n  const contentRef = useRef();\n  const state = useMemoOne(() => ({\n    config,\n    horizontal,\n    busy: false,\n    space: 0,\n    current: 0,\n    offset: 0,\n    controller: new Controller({\n      scroll: 0\n    }),\n    layers: /* @__PURE__ */new Set(),\n    container: containerRef,\n    content: contentRef,\n    update: () => update(),\n    scrollTo: offset => scrollTo(offset),\n    stop: () => state.controller.stop()\n  }), []);\n  useEffect(() => {\n    state.config = config;\n  }, [config]);\n  React.useImperativeHandle(ref, () => state);\n  const update = () => {\n    const container = containerRef.current;\n    if (!container) return;\n    const spaceProp = horizontal ? \"clientWidth\" : \"clientHeight\";\n    state.space = container[spaceProp];\n    const scrollType = getScrollType(horizontal);\n    if (enabled) {\n      state.current = container[scrollType];\n    } else {\n      container[scrollType] = state.current = state.offset * state.space;\n    }\n    const content = contentRef.current;\n    if (content) {\n      const sizeProp = horizontal ? \"width\" : \"height\";\n      content.style[sizeProp] = `${state.space * pages}px`;\n    }\n    state.layers.forEach(layer => {\n      layer.setHeight(state.space, true);\n      layer.setPosition(state.space, state.current, true);\n    });\n  };\n  const scrollTo = offset => {\n    const container = containerRef.current;\n    const scrollType = getScrollType(horizontal);\n    state.offset = offset;\n    state.controller.set({\n      scroll: state.current\n    });\n    state.controller.stop().start({\n      scroll: offset * state.space,\n      config,\n      onChange({\n        value: {\n          scroll\n        }\n      }) {\n        container[scrollType] = scroll;\n      }\n    });\n  };\n  const onScroll = event => {\n    if (!state.busy) {\n      state.busy = true;\n      state.current = event.target[getScrollType(horizontal)];\n      raf.onStart(() => {\n        state.layers.forEach(layer => layer.setPosition(state.space, state.current));\n        state.busy = false;\n      });\n    }\n  };\n  useEffect(() => state.update());\n  useOnce(() => {\n    setReady(true);\n    const onResize = () => {\n      const update2 = () => state.update();\n      raf.onFrame(update2);\n      setTimeout(update2, 150);\n    };\n    window.addEventListener(\"resize\", onResize, false);\n    return () => window.removeEventListener(\"resize\", onResize, false);\n  });\n  const overflow = enabled ? {\n    overflowY: horizontal ? \"hidden\" : \"scroll\",\n    overflowX: horizontal ? \"scroll\" : \"hidden\"\n  } : {\n    overflowY: \"hidden\",\n    overflowX: \"hidden\"\n  };\n  return /* @__PURE__ */React.createElement(a.div, {\n    ...rest,\n    ref: containerRef,\n    onScroll,\n    onWheel: enabled ? state.stop : void 0,\n    onTouchStart: enabled ? state.stop : void 0,\n    style: {\n      position: \"absolute\",\n      width: \"100%\",\n      height: \"100%\",\n      ...overflow,\n      WebkitOverflowScrolling: \"touch\",\n      WebkitTransform: START_TRANSLATE,\n      msTransform: START_TRANSLATE,\n      transform: START_TRANSLATE_3D,\n      ...rest.style\n    }\n  }, ready && /* @__PURE__ */React.createElement(React.Fragment, null, /* @__PURE__ */React.createElement(a.div, {\n    ref: contentRef,\n    style: {\n      overflow: \"hidden\",\n      position: \"absolute\",\n      [horizontal ? \"height\" : \"width\"]: \"100%\",\n      [horizontal ? \"width\" : \"height\"]: state.space * pages,\n      WebkitTransform: START_TRANSLATE,\n      msTransform: START_TRANSLATE,\n      transform: START_TRANSLATE_3D,\n      ...props.innerStyle\n    }\n  }, /* @__PURE__ */React.createElement(ParentContext.Provider, {\n    value: state\n  }, mapChildrenRecursive(children, child => !child.props.sticky && child))), /* @__PURE__ */React.createElement(ParentContext.Provider, {\n    value: state\n  }, mapChildrenRecursive(children, child => child.props.sticky && child))));\n}));\nexport { Parallax, ParallaxLayer };","map":{"version":3,"names":["React","useContext","useState","useRef","useEffect","useMemoOne","useOnce","raf","a","Controller","config","configs","ParentContext","createContext","getScrollType","horizontal","mapChildrenRecursive","children","callback","isReactFragment","node","type","Fragment","Children","map","child","props","START_TRANSLATE_3D","START_TRANSLATE","ParallaxLayer","memo","forwardRef","factor","offset","speed","sticky","rest","ref","parent","ctrl","translate","start","space","targetScroll","Math","floor","distance","current","layer","isSticky","setPosition","height","scrollTop","immediate","setSticky","setHeight","end","useImperativeHandle","layerRef","ref2","style","position","set","layers","add","update","delete","translate3d","springs","to","x","y","createElement","div","top","bottom","left","right","backgroundSize","backgroundRepeat","willChange","WebkitTransform","msTransform","transform","Parallax","ready","setReady","pages","innerStyle","_innerStyle","slow","enabled","containerRef","contentRef","state","busy","controller","scroll","Set","container","content","scrollTo","stop","spaceProp","scrollType","sizeProp","forEach","onChange","value","onScroll","event","target","onStart","onResize","update2","onFrame","setTimeout","window","addEventListener","removeEventListener","overflow","overflowY","overflowX","onWheel","onTouchStart","width","WebkitOverflowScrolling","Provider"],"sources":["C:\\Users\\linjc\\Downloads\\HooHacks2024\\frontend\\fall-detection\\node_modules\\@react-spring\\parallax\\src\\index.tsx"],"sourcesContent":["import * as React from 'react'\nimport { useContext, useState, useRef, useEffect, CSSProperties } from 'react'\nimport { useMemoOne, useOnce, raf } from '@react-spring/shared'\nimport {\n  a,\n  Controller,\n  SpringConfig,\n  config as configs,\n} from '@react-spring/web'\n\nconst ParentContext = React.createContext<any>(null)\n\nfunction getScrollType(horizontal: boolean) {\n  return horizontal ? 'scrollLeft' : 'scrollTop'\n}\n\nfunction mapChildrenRecursive(\n  children: React.ReactNode,\n  callback: Function\n): React.ReactNode {\n  const isReactFragment = (node: any) => {\n    if (node.type) {\n      return node.type === React.Fragment\n    }\n    return node === React.Fragment\n  }\n\n  return React.Children.map(children, (child: any) =>\n    isReactFragment(child)\n      ? mapChildrenRecursive(child.props.children, callback)\n      : callback(child)\n  )\n}\n\nconst START_TRANSLATE_3D = 'translate3d(0px,0px,0px)'\nconst START_TRANSLATE = 'translate(0px,0px)'\n\nexport interface IParallaxLayer {\n  horizontal: boolean\n  sticky: StickyConfig\n  isSticky: boolean\n  setHeight(height: number, immediate?: boolean): void\n  setPosition(height: number, scrollTop: number, immediate?: boolean): void\n}\n\nexport interface IParallax {\n  config: ConfigProp\n  horizontal: boolean\n  busy: boolean\n  space: number\n  offset: number\n  current: number\n  controller: Controller<{ scroll: number }>\n  layers: Set<IParallaxLayer>\n  container: React.MutableRefObject<any>\n  content: React.MutableRefObject<any>\n  scrollTo(offset: number): void\n  update(): void\n  stop(): void\n}\n\ntype ViewProps = React.ComponentPropsWithoutRef<'div'>\n\ntype StickyConfig = { start?: number; end?: number } | undefined\n\nexport interface ParallaxLayerProps extends ViewProps {\n  horizontal?: boolean\n  /** Size of a page, (1=100%, 1.5=1 and 1/2, ...) */\n  factor?: number\n  /** Determines where the layer will be at when scrolled to (0=start, 1=1st page, ...) */\n  offset?: number\n  /** Shifts the layer in accordance to its offset, values can be positive or negative */\n  speed?: number\n  /** Layer will be sticky between these two offsets, all other props are ignored */\n  sticky?: StickyConfig\n}\n\nexport const ParallaxLayer = React.memo(\n  React.forwardRef<IParallaxLayer, ParallaxLayerProps>(\n    (\n      { horizontal, factor = 1, offset = 0, speed = 0, sticky, ...rest },\n      ref\n    ) => {\n      // Our parent controls our height and position.\n      const parent = useContext<IParallax>(ParentContext)\n\n      // This is how we animate.\n      const ctrl = useMemoOne(() => {\n        let translate\n        if (sticky) {\n          const start = sticky.start || 0\n          translate = start * parent.space\n        } else {\n          const targetScroll = Math.floor(offset) * parent.space\n          const distance = parent.space * offset + targetScroll * speed\n          translate = -(parent.current * speed) + distance\n        }\n        type Animated = { space: number; translate: number }\n        return new Controller<Animated>({\n          space: sticky ? parent.space : parent.space * factor,\n          translate,\n        })\n      }, [])\n\n      // Create the layer.\n      const layer = useMemoOne<IParallaxLayer>(\n        () => ({\n          horizontal:\n            horizontal === undefined || sticky ? parent.horizontal : horizontal,\n          sticky: undefined,\n          isSticky: false,\n          setPosition(height, scrollTop, immediate = false) {\n            if (sticky) {\n              setSticky(height, scrollTop)\n            } else {\n              const targetScroll = Math.floor(offset) * height\n              const distance = height * offset + targetScroll * speed\n              ctrl.start({\n                translate: -(scrollTop * speed) + distance,\n                config: parent.config,\n                immediate,\n              })\n            }\n          },\n          setHeight(height, immediate = false) {\n            ctrl.start({\n              space: sticky ? height : height * factor,\n              config: parent.config,\n              immediate,\n            })\n          },\n        }),\n        []\n      )\n\n      useOnce(() => {\n        if (sticky) {\n          const start = sticky.start || 0\n          const end = sticky.end || start + 1\n          layer.sticky = { start, end }\n        }\n      })\n\n      React.useImperativeHandle(ref, () => layer)\n\n      const layerRef = useRef<any>()\n\n      const setSticky = (height: number, scrollTop: number) => {\n        const start = layer.sticky!.start! * height\n        const end = layer.sticky!.end! * height\n        const isSticky = scrollTop >= start && scrollTop <= end\n\n        if (isSticky === layer.isSticky) return\n        layer.isSticky = isSticky\n\n        const ref = layerRef.current\n        ref.style.position = isSticky ? 'sticky' : 'absolute'\n        ctrl.set({\n          translate: isSticky ? 0 : scrollTop < start ? start : end,\n        })\n      }\n\n      // Register the layer with our parent.\n      useOnce(() => {\n        if (parent) {\n          parent.layers.add(layer)\n          parent.update()\n          return () => {\n            parent.layers.delete(layer)\n            parent.update()\n          }\n        }\n      })\n\n      const translate3d = ctrl.springs.translate.to(\n        layer.horizontal\n          ? x => `translate3d(${x}px,0,0)`\n          : y => `translate3d(0,${y}px,0)`\n      )\n\n      return (\n        <a.div\n          {...rest}\n          ref={layerRef}\n          style={{\n            position: 'absolute',\n            top: 0,\n            bottom: 0,\n            left: 0,\n            right: 0,\n            backgroundSize: 'auto',\n            backgroundRepeat: 'no-repeat',\n            willChange: 'transform',\n            [layer.horizontal ? 'height' : 'width']: '100%',\n            [layer.horizontal ? 'width' : 'height']: ctrl.springs.space,\n            WebkitTransform: translate3d,\n            msTransform: translate3d,\n            transform: translate3d,\n            ...rest.style,\n          }}\n        />\n      )\n    }\n  )\n)\n\ntype ConfigProp = SpringConfig | ((key: string) => SpringConfig)\n\nexport interface ParallaxProps extends ViewProps {\n  /** Determines the total space of the inner content where each page takes 100% of the visible container */\n  pages: number\n  config?: ConfigProp\n  enabled?: boolean\n  horizontal?: boolean\n  innerStyle?: CSSProperties\n  children: React.ReactNode\n}\n\nexport const Parallax = React.memo(\n  React.forwardRef<IParallax, ParallaxProps>((props, ref) => {\n    const [ready, setReady] = useState(false)\n    const {\n      pages,\n      innerStyle: _innerStyle,\n      config = configs.slow,\n      enabled = true,\n      horizontal = false,\n      children,\n      ...rest\n    } = props\n\n    const containerRef = useRef<any>()\n    const contentRef = useRef<any>()\n\n    const state: IParallax = useMemoOne(\n      () => ({\n        config,\n        horizontal,\n        busy: false,\n        space: 0,\n        current: 0,\n        offset: 0,\n        controller: new Controller({ scroll: 0 }),\n        layers: new Set<IParallaxLayer>(),\n        container: containerRef,\n        content: contentRef,\n        update: () => update(),\n        scrollTo: offset => scrollTo(offset),\n        stop: () => state.controller.stop(),\n      }),\n      []\n    )\n\n    useEffect(() => {\n      state.config = config\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [config])\n\n    React.useImperativeHandle(ref, () => state)\n\n    const update = () => {\n      const container = containerRef.current\n      if (!container) return\n\n      const spaceProp = horizontal ? 'clientWidth' : 'clientHeight'\n      state.space = container[spaceProp]\n\n      const scrollType = getScrollType(horizontal)\n      if (enabled) {\n        state.current = container[scrollType]\n      } else {\n        container[scrollType] = state.current = state.offset * state.space\n      }\n\n      const content = contentRef.current\n      if (content) {\n        const sizeProp = horizontal ? 'width' : 'height'\n        content.style[sizeProp] = `${state.space * pages}px`\n      }\n\n      state.layers.forEach(layer => {\n        layer.setHeight(state.space, true)\n        layer.setPosition(state.space, state.current, true)\n      })\n    }\n\n    const scrollTo = (offset: number) => {\n      const container = containerRef.current\n      const scrollType = getScrollType(horizontal)\n\n      state.offset = offset\n\n      state.controller.set({ scroll: state.current })\n      state.controller.stop().start({\n        scroll: offset * state.space,\n        config,\n        onChange({ value: { scroll } }: any) {\n          container[scrollType] = scroll\n        },\n      })\n    }\n\n    const onScroll = (event: any) => {\n      if (!state.busy) {\n        state.busy = true\n        state.current = event.target[getScrollType(horizontal)]\n        raf.onStart(() => {\n          state.layers.forEach(layer =>\n            layer.setPosition(state.space, state.current)\n          )\n          state.busy = false\n        })\n      }\n    }\n\n    useEffect(() => state.update())\n    useOnce(() => {\n      setReady(true)\n\n      const onResize = () => {\n        const update = () => state.update()\n        raf.onFrame(update)\n        setTimeout(update, 150) // Some browsers don't fire on maximize!\n      }\n\n      window.addEventListener('resize', onResize, false)\n      return () => window.removeEventListener('resize', onResize, false)\n    })\n\n    const overflow: React.CSSProperties = enabled\n      ? {\n          overflowY: horizontal ? 'hidden' : 'scroll',\n          overflowX: horizontal ? 'scroll' : 'hidden',\n        }\n      : {\n          overflowY: 'hidden',\n          overflowX: 'hidden',\n        }\n\n    return (\n      <a.div\n        {...rest}\n        ref={containerRef}\n        onScroll={onScroll}\n        onWheel={enabled ? state.stop : undefined}\n        onTouchStart={enabled ? state.stop : undefined}\n        style={{\n          position: 'absolute',\n          width: '100%',\n          height: '100%',\n          ...overflow,\n          WebkitOverflowScrolling: 'touch',\n          WebkitTransform: START_TRANSLATE,\n          msTransform: START_TRANSLATE,\n          transform: START_TRANSLATE_3D,\n          ...rest.style,\n        }}\n      >\n        {ready && (\n          <>\n            <a.div\n              ref={contentRef}\n              style={{\n                overflow: 'hidden',\n                position: 'absolute',\n                [horizontal ? 'height' : 'width']: '100%',\n                [horizontal ? 'width' : 'height']: state.space * pages,\n                WebkitTransform: START_TRANSLATE,\n                msTransform: START_TRANSLATE,\n                transform: START_TRANSLATE_3D,\n                ...props.innerStyle,\n              }}\n            >\n              <ParentContext.Provider value={state}>\n                {mapChildrenRecursive(\n                  children,\n                  (child: any) => !child.props.sticky && child\n                )}\n              </ParentContext.Provider>\n            </a.div>\n            <ParentContext.Provider value={state}>\n              {mapChildrenRecursive(\n                children,\n                (child: any) => child.props.sticky && child\n              )}\n            </ParentContext.Provider>\n          </>\n        )}\n      </a.div>\n    )\n  })\n)\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}