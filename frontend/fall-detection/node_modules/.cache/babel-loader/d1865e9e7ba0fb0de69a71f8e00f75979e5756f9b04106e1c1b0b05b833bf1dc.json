{"ast":null,"code":"// src/index.tsx\nimport * as React from \"react\";\nimport { useContext, useState, useRef, useEffect } from \"react\";\nimport { useMemoOne, useOnce, raf } from \"@react-spring/shared\";\nimport { a, Controller, config as configs } from \"@react-spring/web\";\nvar ParentContext = React.createContext(null);\nfunction getScrollType(horizontal) {\n  return horizontal ? \"scrollLeft\" : \"scrollTop\";\n}\nfunction mapChildrenRecursive(children, callback) {\n  const isReactFragment = node => {\n    if (node.type) {\n      return node.type === React.Fragment;\n    }\n    return node === React.Fragment;\n  };\n  return React.Children.map(children, child => isReactFragment(child) ? mapChildrenRecursive(child.props.children, callback) : callback(child));\n}\nvar START_TRANSLATE_3D = \"translate3d(0px,0px,0px)\";\nvar START_TRANSLATE = \"translate(0px,0px)\";\nvar ParallaxLayer = React.memo(React.forwardRef((_ref, ref) => {\n  let {\n    horizontal,\n    factor = 1,\n    offset = 0,\n    speed = 0,\n    sticky,\n    ...rest\n  } = _ref;\n  const parent = useContext(ParentContext);\n  const ctrl = useMemoOne(() => {\n    let translate;\n    if (sticky) {\n      const start = sticky.start || 0;\n      translate = start * parent.space;\n    } else {\n      const targetScroll = Math.floor(offset) * parent.space;\n      const distance = parent.space * offset + targetScroll * speed;\n      translate = -(parent.current * speed) + distance;\n    }\n    return new Controller({\n      space: sticky ? parent.space : parent.space * factor,\n      translate\n    });\n  }, []);\n  const layer = useMemoOne(() => ({\n    horizontal: horizontal === void 0 || sticky ? parent.horizontal : horizontal,\n    sticky: void 0,\n    isSticky: false,\n    setPosition(height, scrollTop) {\n      let immediate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      if (sticky) {\n        setSticky(height, scrollTop);\n      } else {\n        const targetScroll = Math.floor(offset) * height;\n        const distance = height * offset + targetScroll * speed;\n        ctrl.start({\n          translate: -(scrollTop * speed) + distance,\n          config: parent.config,\n          immediate\n        });\n      }\n    },\n    setHeight(height) {\n      let immediate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      ctrl.start({\n        space: sticky ? height : height * factor,\n        config: parent.config,\n        immediate\n      });\n    }\n  }), []);\n  useOnce(() => {\n    if (sticky) {\n      const start = sticky.start || 0;\n      const end = sticky.end || start + 1;\n      layer.sticky = {\n        start,\n        end\n      };\n    }\n  });\n  React.useImperativeHandle(ref, () => layer);\n  const layerRef = useRef();\n  const setSticky = (height, scrollTop) => {\n    const start = layer.sticky.start * height;\n    const end = layer.sticky.end * height;\n    const isSticky = scrollTop >= start && scrollTop <= end;\n    if (isSticky === layer.isSticky) return;\n    layer.isSticky = isSticky;\n    const ref2 = layerRef.current;\n    ref2.style.position = isSticky ? \"sticky\" : \"absolute\";\n    ctrl.set({\n      translate: isSticky ? 0 : scrollTop < start ? start : end\n    });\n  };\n  useOnce(() => {\n    if (parent) {\n      parent.layers.add(layer);\n      parent.update();\n      return () => {\n        parent.layers.delete(layer);\n        parent.update();\n      };\n    }\n  });\n  const translate3d = ctrl.springs.translate.to(layer.horizontal ? x => \"translate3d(\".concat(x, \"px,0,0)\") : y => \"translate3d(0,\".concat(y, \"px,0)\"));\n  return /* @__PURE__ */React.createElement(a.div, {\n    ...rest,\n    ref: layerRef,\n    style: {\n      position: \"absolute\",\n      top: 0,\n      bottom: 0,\n      left: 0,\n      right: 0,\n      backgroundSize: \"auto\",\n      backgroundRepeat: \"no-repeat\",\n      willChange: \"transform\",\n      [layer.horizontal ? \"height\" : \"width\"]: \"100%\",\n      [layer.horizontal ? \"width\" : \"height\"]: ctrl.springs.space,\n      WebkitTransform: translate3d,\n      msTransform: translate3d,\n      transform: translate3d,\n      ...rest.style\n    }\n  });\n}));\nvar Parallax = React.memo(React.forwardRef((props, ref) => {\n  const [ready, setReady] = useState(false);\n  const {\n    pages,\n    innerStyle: _innerStyle,\n    config = configs.slow,\n    enabled = true,\n    horizontal = false,\n    children,\n    ...rest\n  } = props;\n  const containerRef = useRef();\n  const contentRef = useRef();\n  const state = useMemoOne(() => ({\n    config,\n    horizontal,\n    busy: false,\n    space: 0,\n    current: 0,\n    offset: 0,\n    controller: new Controller({\n      scroll: 0\n    }),\n    layers: /* @__PURE__ */new Set(),\n    container: containerRef,\n    content: contentRef,\n    update: () => update(),\n    scrollTo: offset => scrollTo(offset),\n    stop: () => state.controller.stop()\n  }), []);\n  useEffect(() => {\n    state.config = config;\n  }, [config]);\n  React.useImperativeHandle(ref, () => state);\n  const update = () => {\n    const container = containerRef.current;\n    if (!container) return;\n    const spaceProp = horizontal ? \"clientWidth\" : \"clientHeight\";\n    state.space = container[spaceProp];\n    const scrollType = getScrollType(horizontal);\n    if (enabled) {\n      state.current = container[scrollType];\n    } else {\n      container[scrollType] = state.current = state.offset * state.space;\n    }\n    const content = contentRef.current;\n    if (content) {\n      const sizeProp = horizontal ? \"width\" : \"height\";\n      content.style[sizeProp] = \"\".concat(state.space * pages, \"px\");\n    }\n    state.layers.forEach(layer => {\n      layer.setHeight(state.space, true);\n      layer.setPosition(state.space, state.current, true);\n    });\n  };\n  const scrollTo = offset => {\n    const container = containerRef.current;\n    const scrollType = getScrollType(horizontal);\n    state.offset = offset;\n    state.controller.set({\n      scroll: state.current\n    });\n    state.controller.stop().start({\n      scroll: offset * state.space,\n      config,\n      onChange(_ref2) {\n        let {\n          value: {\n            scroll\n          }\n        } = _ref2;\n        container[scrollType] = scroll;\n      }\n    });\n  };\n  const onScroll = event => {\n    if (!state.busy) {\n      state.busy = true;\n      state.current = event.target[getScrollType(horizontal)];\n      raf.onStart(() => {\n        state.layers.forEach(layer => layer.setPosition(state.space, state.current));\n        state.busy = false;\n      });\n    }\n  };\n  useEffect(() => state.update());\n  useOnce(() => {\n    setReady(true);\n    const onResize = () => {\n      const update2 = () => state.update();\n      raf.onFrame(update2);\n      setTimeout(update2, 150);\n    };\n    window.addEventListener(\"resize\", onResize, false);\n    return () => window.removeEventListener(\"resize\", onResize, false);\n  });\n  const overflow = enabled ? {\n    overflowY: horizontal ? \"hidden\" : \"scroll\",\n    overflowX: horizontal ? \"scroll\" : \"hidden\"\n  } : {\n    overflowY: \"hidden\",\n    overflowX: \"hidden\"\n  };\n  return /* @__PURE__ */React.createElement(a.div, {\n    ...rest,\n    ref: containerRef,\n    onScroll,\n    onWheel: enabled ? state.stop : void 0,\n    onTouchStart: enabled ? state.stop : void 0,\n    style: {\n      position: \"absolute\",\n      width: \"100%\",\n      height: \"100%\",\n      ...overflow,\n      WebkitOverflowScrolling: \"touch\",\n      WebkitTransform: START_TRANSLATE,\n      msTransform: START_TRANSLATE,\n      transform: START_TRANSLATE_3D,\n      ...rest.style\n    }\n  }, ready && /* @__PURE__ */React.createElement(React.Fragment, null, /* @__PURE__ */React.createElement(a.div, {\n    ref: contentRef,\n    style: {\n      overflow: \"hidden\",\n      position: \"absolute\",\n      [horizontal ? \"height\" : \"width\"]: \"100%\",\n      [horizontal ? \"width\" : \"height\"]: state.space * pages,\n      WebkitTransform: START_TRANSLATE,\n      msTransform: START_TRANSLATE,\n      transform: START_TRANSLATE_3D,\n      ...props.innerStyle\n    }\n  }, /* @__PURE__ */React.createElement(ParentContext.Provider, {\n    value: state\n  }, mapChildrenRecursive(children, child => !child.props.sticky && child))), /* @__PURE__ */React.createElement(ParentContext.Provider, {\n    value: state\n  }, mapChildrenRecursive(children, child => child.props.sticky && child))));\n}));\nexport { Parallax, ParallaxLayer };","map":{"version":3,"names":["React","useContext","useState","useRef","useEffect","useMemoOne","useOnce","raf","a","Controller","config","configs","ParentContext","createContext","getScrollType","horizontal","mapChildrenRecursive","children","callback","isReactFragment","node","type","Fragment","Children","map","child","props","START_TRANSLATE_3D","START_TRANSLATE","ParallaxLayer","memo","forwardRef","_ref","ref","factor","offset","speed","sticky","rest","parent","ctrl","translate","start","space","targetScroll","Math","floor","distance","current","layer","isSticky","setPosition","height","scrollTop","immediate","arguments","length","undefined","setSticky","setHeight","end","useImperativeHandle","layerRef","ref2","style","position","set","layers","add","update","delete","translate3d","springs","to","x","concat","y","createElement","div","top","bottom","left","right","backgroundSize","backgroundRepeat","willChange","WebkitTransform","msTransform","transform","Parallax","ready","setReady","pages","innerStyle","_innerStyle","slow","enabled","containerRef","contentRef","state","busy","controller","scroll","Set","container","content","scrollTo","stop","spaceProp","scrollType","sizeProp","forEach","onChange","_ref2","value","onScroll","event","target","onStart","onResize","update2","onFrame","setTimeout","window","addEventListener","removeEventListener","overflow","overflowY","overflowX","onWheel","onTouchStart","width","WebkitOverflowScrolling","Provider"],"sources":["C:\\Users\\linjc\\Downloads\\HooHacks2024\\frontend\\fall-detection\\node_modules\\@react-spring\\parallax\\src\\index.tsx"],"sourcesContent":["import * as React from 'react'\nimport { useContext, useState, useRef, useEffect, CSSProperties } from 'react'\nimport { useMemoOne, useOnce, raf } from '@react-spring/shared'\nimport {\n  a,\n  Controller,\n  SpringConfig,\n  config as configs,\n} from '@react-spring/web'\n\nconst ParentContext = React.createContext<any>(null)\n\nfunction getScrollType(horizontal: boolean) {\n  return horizontal ? 'scrollLeft' : 'scrollTop'\n}\n\nfunction mapChildrenRecursive(\n  children: React.ReactNode,\n  callback: Function\n): React.ReactNode {\n  const isReactFragment = (node: any) => {\n    if (node.type) {\n      return node.type === React.Fragment\n    }\n    return node === React.Fragment\n  }\n\n  return React.Children.map(children, (child: any) =>\n    isReactFragment(child)\n      ? mapChildrenRecursive(child.props.children, callback)\n      : callback(child)\n  )\n}\n\nconst START_TRANSLATE_3D = 'translate3d(0px,0px,0px)'\nconst START_TRANSLATE = 'translate(0px,0px)'\n\nexport interface IParallaxLayer {\n  horizontal: boolean\n  sticky: StickyConfig\n  isSticky: boolean\n  setHeight(height: number, immediate?: boolean): void\n  setPosition(height: number, scrollTop: number, immediate?: boolean): void\n}\n\nexport interface IParallax {\n  config: ConfigProp\n  horizontal: boolean\n  busy: boolean\n  space: number\n  offset: number\n  current: number\n  controller: Controller<{ scroll: number }>\n  layers: Set<IParallaxLayer>\n  container: React.MutableRefObject<any>\n  content: React.MutableRefObject<any>\n  scrollTo(offset: number): void\n  update(): void\n  stop(): void\n}\n\ntype ViewProps = React.ComponentPropsWithoutRef<'div'>\n\ntype StickyConfig = { start?: number; end?: number } | undefined\n\nexport interface ParallaxLayerProps extends ViewProps {\n  horizontal?: boolean\n  /** Size of a page, (1=100%, 1.5=1 and 1/2, ...) */\n  factor?: number\n  /** Determines where the layer will be at when scrolled to (0=start, 1=1st page, ...) */\n  offset?: number\n  /** Shifts the layer in accordance to its offset, values can be positive or negative */\n  speed?: number\n  /** Layer will be sticky between these two offsets, all other props are ignored */\n  sticky?: StickyConfig\n}\n\nexport const ParallaxLayer = React.memo(\n  React.forwardRef<IParallaxLayer, ParallaxLayerProps>(\n    (\n      { horizontal, factor = 1, offset = 0, speed = 0, sticky, ...rest },\n      ref\n    ) => {\n      // Our parent controls our height and position.\n      const parent = useContext<IParallax>(ParentContext)\n\n      // This is how we animate.\n      const ctrl = useMemoOne(() => {\n        let translate\n        if (sticky) {\n          const start = sticky.start || 0\n          translate = start * parent.space\n        } else {\n          const targetScroll = Math.floor(offset) * parent.space\n          const distance = parent.space * offset + targetScroll * speed\n          translate = -(parent.current * speed) + distance\n        }\n        type Animated = { space: number; translate: number }\n        return new Controller<Animated>({\n          space: sticky ? parent.space : parent.space * factor,\n          translate,\n        })\n      }, [])\n\n      // Create the layer.\n      const layer = useMemoOne<IParallaxLayer>(\n        () => ({\n          horizontal:\n            horizontal === undefined || sticky ? parent.horizontal : horizontal,\n          sticky: undefined,\n          isSticky: false,\n          setPosition(height, scrollTop, immediate = false) {\n            if (sticky) {\n              setSticky(height, scrollTop)\n            } else {\n              const targetScroll = Math.floor(offset) * height\n              const distance = height * offset + targetScroll * speed\n              ctrl.start({\n                translate: -(scrollTop * speed) + distance,\n                config: parent.config,\n                immediate,\n              })\n            }\n          },\n          setHeight(height, immediate = false) {\n            ctrl.start({\n              space: sticky ? height : height * factor,\n              config: parent.config,\n              immediate,\n            })\n          },\n        }),\n        []\n      )\n\n      useOnce(() => {\n        if (sticky) {\n          const start = sticky.start || 0\n          const end = sticky.end || start + 1\n          layer.sticky = { start, end }\n        }\n      })\n\n      React.useImperativeHandle(ref, () => layer)\n\n      const layerRef = useRef<any>()\n\n      const setSticky = (height: number, scrollTop: number) => {\n        const start = layer.sticky!.start! * height\n        const end = layer.sticky!.end! * height\n        const isSticky = scrollTop >= start && scrollTop <= end\n\n        if (isSticky === layer.isSticky) return\n        layer.isSticky = isSticky\n\n        const ref = layerRef.current\n        ref.style.position = isSticky ? 'sticky' : 'absolute'\n        ctrl.set({\n          translate: isSticky ? 0 : scrollTop < start ? start : end,\n        })\n      }\n\n      // Register the layer with our parent.\n      useOnce(() => {\n        if (parent) {\n          parent.layers.add(layer)\n          parent.update()\n          return () => {\n            parent.layers.delete(layer)\n            parent.update()\n          }\n        }\n      })\n\n      const translate3d = ctrl.springs.translate.to(\n        layer.horizontal\n          ? x => `translate3d(${x}px,0,0)`\n          : y => `translate3d(0,${y}px,0)`\n      )\n\n      return (\n        <a.div\n          {...rest}\n          ref={layerRef}\n          style={{\n            position: 'absolute',\n            top: 0,\n            bottom: 0,\n            left: 0,\n            right: 0,\n            backgroundSize: 'auto',\n            backgroundRepeat: 'no-repeat',\n            willChange: 'transform',\n            [layer.horizontal ? 'height' : 'width']: '100%',\n            [layer.horizontal ? 'width' : 'height']: ctrl.springs.space,\n            WebkitTransform: translate3d,\n            msTransform: translate3d,\n            transform: translate3d,\n            ...rest.style,\n          }}\n        />\n      )\n    }\n  )\n)\n\ntype ConfigProp = SpringConfig | ((key: string) => SpringConfig)\n\nexport interface ParallaxProps extends ViewProps {\n  /** Determines the total space of the inner content where each page takes 100% of the visible container */\n  pages: number\n  config?: ConfigProp\n  enabled?: boolean\n  horizontal?: boolean\n  innerStyle?: CSSProperties\n  children: React.ReactNode\n}\n\nexport const Parallax = React.memo(\n  React.forwardRef<IParallax, ParallaxProps>((props, ref) => {\n    const [ready, setReady] = useState(false)\n    const {\n      pages,\n      innerStyle: _innerStyle,\n      config = configs.slow,\n      enabled = true,\n      horizontal = false,\n      children,\n      ...rest\n    } = props\n\n    const containerRef = useRef<any>()\n    const contentRef = useRef<any>()\n\n    const state: IParallax = useMemoOne(\n      () => ({\n        config,\n        horizontal,\n        busy: false,\n        space: 0,\n        current: 0,\n        offset: 0,\n        controller: new Controller({ scroll: 0 }),\n        layers: new Set<IParallaxLayer>(),\n        container: containerRef,\n        content: contentRef,\n        update: () => update(),\n        scrollTo: offset => scrollTo(offset),\n        stop: () => state.controller.stop(),\n      }),\n      []\n    )\n\n    useEffect(() => {\n      state.config = config\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [config])\n\n    React.useImperativeHandle(ref, () => state)\n\n    const update = () => {\n      const container = containerRef.current\n      if (!container) return\n\n      const spaceProp = horizontal ? 'clientWidth' : 'clientHeight'\n      state.space = container[spaceProp]\n\n      const scrollType = getScrollType(horizontal)\n      if (enabled) {\n        state.current = container[scrollType]\n      } else {\n        container[scrollType] = state.current = state.offset * state.space\n      }\n\n      const content = contentRef.current\n      if (content) {\n        const sizeProp = horizontal ? 'width' : 'height'\n        content.style[sizeProp] = `${state.space * pages}px`\n      }\n\n      state.layers.forEach(layer => {\n        layer.setHeight(state.space, true)\n        layer.setPosition(state.space, state.current, true)\n      })\n    }\n\n    const scrollTo = (offset: number) => {\n      const container = containerRef.current\n      const scrollType = getScrollType(horizontal)\n\n      state.offset = offset\n\n      state.controller.set({ scroll: state.current })\n      state.controller.stop().start({\n        scroll: offset * state.space,\n        config,\n        onChange({ value: { scroll } }: any) {\n          container[scrollType] = scroll\n        },\n      })\n    }\n\n    const onScroll = (event: any) => {\n      if (!state.busy) {\n        state.busy = true\n        state.current = event.target[getScrollType(horizontal)]\n        raf.onStart(() => {\n          state.layers.forEach(layer =>\n            layer.setPosition(state.space, state.current)\n          )\n          state.busy = false\n        })\n      }\n    }\n\n    useEffect(() => state.update())\n    useOnce(() => {\n      setReady(true)\n\n      const onResize = () => {\n        const update = () => state.update()\n        raf.onFrame(update)\n        setTimeout(update, 150) // Some browsers don't fire on maximize!\n      }\n\n      window.addEventListener('resize', onResize, false)\n      return () => window.removeEventListener('resize', onResize, false)\n    })\n\n    const overflow: React.CSSProperties = enabled\n      ? {\n          overflowY: horizontal ? 'hidden' : 'scroll',\n          overflowX: horizontal ? 'scroll' : 'hidden',\n        }\n      : {\n          overflowY: 'hidden',\n          overflowX: 'hidden',\n        }\n\n    return (\n      <a.div\n        {...rest}\n        ref={containerRef}\n        onScroll={onScroll}\n        onWheel={enabled ? state.stop : undefined}\n        onTouchStart={enabled ? state.stop : undefined}\n        style={{\n          position: 'absolute',\n          width: '100%',\n          height: '100%',\n          ...overflow,\n          WebkitOverflowScrolling: 'touch',\n          WebkitTransform: START_TRANSLATE,\n          msTransform: START_TRANSLATE,\n          transform: START_TRANSLATE_3D,\n          ...rest.style,\n        }}\n      >\n        {ready && (\n          <>\n            <a.div\n              ref={contentRef}\n              style={{\n                overflow: 'hidden',\n                position: 'absolute',\n                [horizontal ? 'height' : 'width']: '100%',\n                [horizontal ? 'width' : 'height']: state.space * pages,\n                WebkitTransform: START_TRANSLATE,\n                msTransform: START_TRANSLATE,\n                transform: START_TRANSLATE_3D,\n                ...props.innerStyle,\n              }}\n            >\n              <ParentContext.Provider value={state}>\n                {mapChildrenRecursive(\n                  children,\n                  (child: any) => !child.props.sticky && child\n                )}\n              </ParentContext.Provider>\n            </a.div>\n            <ParentContext.Provider value={state}>\n              {mapChildrenRecursive(\n                children,\n                (child: any) => child.props.sticky && child\n              )}\n            </ParentContext.Provider>\n          </>\n        )}\n      </a.div>\n    )\n  })\n)\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}